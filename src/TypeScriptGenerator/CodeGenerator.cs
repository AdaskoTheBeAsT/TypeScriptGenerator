using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using TypeScriptGenerator.Exceptions;

#pragma warning disable 162

namespace TypeScriptGenerator
{
    [Generator]
    public class CodeGenerator
        : ISourceGenerator
    {
        public const string Header = "// Generated by https://github.com/AdaskoTheBeAsT/TypeScriptGenerator";
        public const string ModelsPath = "models";
        public const string EnumsPath = "enums";
        public const string ServicesPath = "services";
        public const string FlagsAttributeFullName = "System.FlagsAttribute";
        public const string ControllerBaseTypeName = "Microsoft.AspNetCore.Mvc.ControllerBase";
        public const string ControllerTypeName = "Microsoft.AspNetCore.Mvc.Controller";
        public const string IncludeAttributeFullName = "TypeScriptGenerator.Attributes.IncludeAttribute";
        public const string CustomNameAttributeFullName = "TypeScriptGenerator.Attributes.CustomNameAttribute";
        public const string BuildPropertyOutputPath = "build_property.typescriptgeneratoroutputpath";

        public static readonly Encoding Uft8WithoutBomEncoding = new UTF8Encoding(false, true);

        public void Execute(GeneratorExecutionContext context)
        {
            if (!RegisterAttributes(context, out var receiver, out var compilation))
            {
                return;
            }

            if (!context.AnalyzerConfigOptions.GlobalOptions.TryGetValue(
                BuildPropertyOutputPath,
                out string? typeScriptGeneratorOutputPath))
            {
                return;
            }

            if (!Directory.Exists(typeScriptGeneratorOutputPath))
            {
                Directory.CreateDirectory(typeScriptGeneratorOutputPath);
            }

            // get the newly bound attributes
            var includeAttributeSymbol = compilation!.GetTypeByMetadataName(IncludeAttributeFullName);
            if (includeAttributeSymbol is null)
            {
                throw new SymbolNotFoundException();
            }

            var customNameAttributeSymbol = compilation!.GetTypeByMetadataName(CustomNameAttributeFullName);
            if (customNameAttributeSymbol is null)
            {
                throw new SymbolNotFoundException();
            }

            ////CleanOutputFolders(TargetPath);
            // loop over the candidate fields, and keep the ones that are actually annotated
            var enumSymbols = FilterEnumSymbols(receiver!, compilation, includeAttributeSymbol!);
            if (enumSymbols.Count > 0)
            {
                var enumHelperGenerator = new EnumHelperGenerator();
                enumHelperGenerator.Generate(typeScriptGeneratorOutputPath);
            }

            var enumCodeGenerator = new EnumCodeGenerator();
            enumCodeGenerator.Generate(
                typeScriptGeneratorOutputPath,
                compilation!,
                enumSymbols);
            var classSymbols = FilterClassSymbols(receiver!, compilation, includeAttributeSymbol!);
            var modelCodeGenerator = new ModelCodeGenerator();
            modelCodeGenerator.Generate(typeScriptGeneratorOutputPath, compilation, classSymbols);
        }

        public void Initialize(GeneratorInitializationContext context)
        {
#if DEBUG
            if (!Debugger.IsAttached)
            {
                ////Debugger.Launch();
            }
#endif
            context.RegisterForSyntaxNotifications(() => new CandidateReceiver());
        }

        internal bool RegisterAttributes(
            GeneratorExecutionContext context,
            out CandidateReceiver? typescriptCandidateReceiver,
            out Compilation? compilation)
        {
            // retrieve the populated receiver
            if (!(context.SyntaxReceiver is CandidateReceiver receiver))
            {
                typescriptCandidateReceiver = null;
                compilation = null;
                return false;
            }

            typescriptCandidateReceiver = receiver;

            // TODO: we should allow source generators to provide source during initialize, so that this step isn't required.
            if (!(context.Compilation is CSharpCompilation))
            {
                compilation = null;
                return false;
            }

            compilation = context.Compilation;

            return true;
        }

        internal List<NamedTypeSymbolData> FilterClassSymbols(
            CandidateReceiver receiver,
            Compilation compilation,
            INamedTypeSymbol attributeSymbol)
        {
            var classSymbols = new List<NamedTypeSymbolData>();
            foreach (var classDeclarationSyntax in receiver.CandidateClasses)
            {
                var model = compilation.GetSemanticModel(classDeclarationSyntax.SyntaxTree);
                var namedTypeSymbol = model.GetDeclaredSymbol(classDeclarationSyntax);

                var attributeClass = namedTypeSymbol?.GetAttributes().FirstOrDefault(
                    a => a.AttributeClass?.Equals(
                        attributeSymbol,
                        SymbolEqualityComparer.Default) == true);
                if (attributeClass != null)
                {
                    var name = attributeClass.ConstructorArguments.FirstOrDefault().Value?.ToString() ?? null;
                    classSymbols.Add(new NamedTypeSymbolData(namedTypeSymbol!, name));
                }
            }

            return classSymbols;
        }

        internal List<NamedTypeSymbolData> FilterEnumSymbols(
            CandidateReceiver receiver,
            Compilation compilation,
            INamedTypeSymbol attributeSymbol)
        {
            var enumSymbols = new List<NamedTypeSymbolData>();
            foreach (var enumDeclarationSyntax in receiver.CandidateEnums)
            {
                var model = compilation.GetSemanticModel(enumDeclarationSyntax.SyntaxTree);
                var namedTypeSymbol = model.GetDeclaredSymbol(enumDeclarationSyntax);
                var attributeClass = namedTypeSymbol?.GetAttributes().FirstOrDefault(
                    a =>
                        a.AttributeClass?.Equals(
                            attributeSymbol,
                            SymbolEqualityComparer.Default) == true);
                if (attributeClass != null)
                {
                    var name = attributeClass.ConstructorArguments.FirstOrDefault().Value?.ToString() ?? null;
                    enumSymbols.Add(new NamedTypeSymbolData(namedTypeSymbol!, name));
                }
            }

            return enumSymbols;
        }

        internal void CleanOutputFolders(string path)
        {
            if (!Directory.Exists(path))
            {
                return;
            }

            var rootDirectoryInfo = new DirectoryInfo(path);
            foreach (var file in rootDirectoryInfo.GetFiles())
            {
                file.Delete();
            }

            var modelsPath = $"{path}/{ModelsPath}";
            var enumsPath = $"{path}/{EnumsPath}";
            var servicesPath = $"{path}/{ServicesPath}";
            CleanFilesAndFolders(modelsPath, enumsPath, servicesPath);
        }

        internal void CleanFilesAndFolders(params string[] paths)
        {
            foreach (var path in paths)
            {
                if (!Directory.Exists(path))
                {
                    continue;
                }

                var directoryInfo = new DirectoryInfo(path);

                foreach (var file in directoryInfo.GetFiles())
                {
                    file.Delete();
                }

                foreach (var dir in directoryInfo.GetDirectories())
                {
                    dir.Delete(true);
                }
            }
        }
    }
}
